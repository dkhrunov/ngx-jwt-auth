# Ngx JWT Auth
<a href="https://jwt.io/">
  <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:sketch="http://www.bohemiancoding.com/sketch/ns" width="144px" height="36px" viewBox="0 0 144 36" version="1.1">
    <title>Compatible</title>
    <desc>Created with Sketch.</desc>
    <defs/>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" sketch:type="MSPage">
        <g id="Artboard-8" sketch:type="MSArtboardGroup" transform="translate(-311.000000, -287.000000)">
            <g id="Compatible" sketch:type="MSLayerGroup" transform="translate(311.000000, 287.000000)">
                <rect id="Rectangle-237" fill="#000000" sketch:type="MSShapeGroup" x="0" y="0" width="144" height="35.8015267" rx="18"/>
                <g id="Group-Copy-5" transform="translate(8.419260, 8.479309)" sketch:type="MSShapeGroup">
                    <g id="Group-Copy-4">
                        <path d="M10.8773693,5.08758538 L10.8773693,-1.33226763e-15 L8.04472108,-1.33226763e-15 L8.04472108,5.08758538 L9.44216089,7.00956207 L10.8773693,5.08758538 Z" id="Shape" fill="#FFFFFF"/>
                        <path d="M8.04472108,13.7553234 L8.04472108,18.8429088 L10.8773693,18.8429088 L10.8773693,13.7553234 L9.44216089,11.8333467 L8.04472108,13.7553234 Z" id="Shape" fill="#FFFFFF"/>
                        <path d="M10.8773693,13.7553234 L13.8610922,17.8630775 L16.1272108,16.2049016 L13.143488,12.0971474 L10.8773693,11.3811169 L10.8773693,13.7553234 Z" id="Shape" fill="#00F2E6"/>
                        <path d="M8.04472108,5.08758538 L5.02322959,0.979831258 L2.75711098,2.63800723 L5.74083382,6.74576135 L8.04472108,7.46179188 L8.04472108,5.08758538 Z" id="Shape" fill="#00F2E6"/>
                        <path d="M5.74083382,6.74576135 L0.906447446,5.16295701 L0.0377686436,7.83865006 L4.87215502,9.4214544 L7.13827363,8.66773805 L5.74083382,6.74576135 Z" id="Shape" fill="#00B9F1"/>
                        <path d="M11.7460482,10.1751708 L13.143488,12.0971474 L17.9778743,13.6799518 L18.8465531,11.0042587 L14.0121668,9.4214544 L11.7460482,10.1751708 Z" id="Shape" fill="#00B9F1"/>
                        <path d="M14.0121668,9.4214544 L18.8465531,7.83865006 L17.9778743,5.16295701 L13.143488,6.74576135 L11.7460482,8.66773805 L14.0121668,9.4214544 Z" id="Shape" fill="#D63AFF"/>
                        <path d="M4.87215502,9.4214544 L0.0377686436,11.0042587 L0.906447446,13.6799518 L5.74083382,12.0971474 L7.13827363,10.1751708 L4.87215502,9.4214544 Z" id="Shape" fill="#D63AFF"/>
                        <path d="M5.74083382,12.0971474 L2.75711098,16.2049016 L5.02322959,17.8630775 L8.04472108,13.7553234 L8.04472108,11.3811169 L5.74083382,12.0971474 Z" id="Shape" fill="#FB015B"/>
                        <path d="M13.143488,6.74576135 L16.1272108,2.63800723 L13.8610922,0.979831258 L10.8773693,5.08758538 L10.8773693,7.46179188 L13.143488,6.74576135 Z" id="Shape" fill="#FB015B"/>
                    </g>
                </g>
                <path d="M38.8776319,19.767424 L38.8776319,13.8922242 L37.3265792,13.8922242 L37.3265792,19.5676672 C37.3265792,20.4371968 36.8918144,20.766208 36.17504,20.766208 C35.7520256,20.766208 35.5052672,20.7192064 35.2467584,20.648704 L35.4582656,22 C35.6580224,22.0352512 36.0222848,22.0822528 36.3865472,22.0822528 C37.8435967,22.0822528 38.8776319,21.41248 38.8776319,19.767424 L38.8776319,19.767424 Z M51.1450493,13.8922242 L49.5822461,13.8922242 L48.1016957,19.6146688 L46.4096382,13.8922242 L44.846835,13.8922242 L43.1547774,19.6146688 L41.6272255,13.8099714 L40.0056703,14.1037314 L42.2734975,22 L43.7422974,22 L45.5401086,16.1012993 L47.3379198,22 L48.8184701,22 L51.1450493,13.8922242 Z M58.3127931,15.2435201 L58.0895355,13.8922242 L51.7913213,13.8922242 L51.7913213,15.2435201 L54.2001532,15.2435201 L54.2001532,22 L55.7629564,22 L55.7629564,15.2435201 L58.3127931,15.2435201 Z M67.8423673,21.4477312 L67.6308602,20.1081856 C67.008089,20.5194496 66.3265658,20.7897088 65.5745402,20.7897088 C64.1409914,20.7897088 63.2009594,19.7321728 63.2009594,17.9461121 C63.2009594,16.1835521 64.0822394,15.0907649 65.5157882,15.0907649 C66.303065,15.0907649 66.9610874,15.4080257 67.4898554,15.8075393 L67.713113,14.3387394 C67.1138426,13.974477 66.3853178,13.7512194 65.4452858,13.7512194 C63.1539578,13.7512194 61.6146555,15.4432769 61.6146555,17.9578625 C61.6146555,20.472448 63.0952058,22.1410048 65.4570362,22.1410048 C66.3735674,22.1410048 67.1960954,21.8589952 67.8423673,21.4477312 L67.8423673,21.4477312 Z M76.1969016,17.9343617 C76.1969016,15.4315265 74.7281016,13.739469 72.4015225,13.739469 C70.0866937,13.739469 68.5826425,15.4432769 68.5826425,17.9578625 C68.5826425,20.4606976 70.0749433,22.1527552 72.3780217,22.1527552 C74.7046008,22.1527552 76.1969016,20.4371968 76.1969016,17.9343617 L76.1969016,17.9343617 Z M74.622348,17.9461121 C74.622348,19.7204224 73.7880696,20.8602112 72.3897721,20.8602112 C71.0032249,20.8602112 70.1689465,19.7204224 70.1689465,17.9461121 C70.1689465,16.1718017 71.0032249,15.0320129 72.3897721,15.0320129 C73.7763192,15.0320129 74.622348,16.1718017 74.622348,17.9461121 L74.622348,17.9461121 Z M86.6312566,22 L86.0084854,13.8922242 L84.0696694,13.8922242 L82.0250999,20.0141824 L79.9687799,13.8922242 L77.9947127,13.8922242 L77.3719416,22 L78.7702391,22 L79.1815031,16.0777985 L81.2378231,22.0235008 L82.6008695,22.0235008 L84.645439,16.0777985 L85.0802038,22 L86.6312566,22 Z M93.4582388,16.3833089 C93.4582388,14.7500033 92.3419509,13.8922242 90.4853877,13.8922242 L88.1118069,13.8922242 L88.1118069,22 L89.6628597,22 L89.6628597,19.0153985 L90.3561333,19.0153985 C92.2126965,19.0153985 93.4582388,18.1341185 93.4582388,16.3833089 L93.4582388,16.3833089 Z M91.9306869,16.4185601 C91.9306869,17.3468417 91.3431669,17.7581057 90.3443829,17.7581057 L89.6628597,17.7581057 L89.6628597,15.1377665 L90.4031349,15.1377665 C91.4019189,15.1377665 91.9306869,15.5725313 91.9306869,16.4185601 L91.9306869,16.4185601 Z M100.896242,21.8002432 L97.9233907,13.856973 L96.2665844,13.856973 L93.2232308,22 L94.7625332,22 L95.5028084,19.94368 L98.5696627,19.94368 L99.3451891,22.0822528 L100.896242,21.8002432 Z M98.1348979,18.6746369 L95.9258228,18.6746369 L97.0303604,15.5490305 L98.1348979,18.6746369 Z M106.994699,15.2435201 L106.771442,13.8922242 L100.473227,13.8922242 L100.473227,15.2435201 L102.882059,15.2435201 L102.882059,22 L104.444863,22 L104.444863,15.2435201 L106.994699,15.2435201 Z M109.720792,22 L109.720792,13.8922242 L108.157989,13.8922242 L108.157989,22 L109.720792,22 Z M116.865035,19.6381696 C116.865035,18.5571329 116.265765,17.9696129 115.360984,17.6876033 C116.066008,17.3938433 116.536024,16.8415745 116.536024,15.9955457 C116.536024,14.7147521 115.666494,13.8922242 113.845182,13.8922242 L111.483352,13.8922242 L111.483352,22 L113.809931,22 C115.713496,22 116.865035,21.236224 116.865035,19.6381696 L116.865035,19.6381696 Z M115.090725,16.1248001 C115.090725,16.8180737 114.608958,17.2293377 113.692427,17.2293377 L112.975653,17.2293377 L112.975653,15.0790145 L113.76293,15.0790145 C114.702962,15.0790145 115.090725,15.4785281 115.090725,16.1248001 L115.090725,16.1248001 Z M115.372734,19.591168 C115.372734,20.4019456 114.796965,20.8132096 113.809931,20.8132096 L112.975653,20.8132096 L112.975653,18.3338753 L113.78643,18.3338753 C114.820466,18.3338753 115.372734,18.7686401 115.372734,19.591168 L115.372734,19.591168 Z M122.610981,22 L122.399473,20.6252032 L119.696882,20.6252032 L119.696882,13.8922242 L118.134078,13.8922242 L118.134078,22 L122.610981,22 Z M128.568433,22 L128.568433,20.6839552 L125.278321,20.6839552 L125.278321,18.4513793 L127.933912,18.4513793 L127.722405,17.1118337 L125.278321,17.1118337 L125.278321,15.2082689 L128.450929,15.2082689 L128.450929,13.8922242 L123.739019,13.8922242 L123.739019,22 L128.568433,22 Z" id="Type-something" fill="#FFFFFF" sketch:type="MSShapeGroup"/>
            </g>
        </g>
    </g>
  </svg>
</a>

<br/>

Библиотека для Token-Based Authentication на основе Access и Refresh токенов.

Эта библиотека настраивается для любых вариантов использования.

## Содержание
- [Описание](#описание)
- [Настройка и применение](#настройка-и-применение)
- [Описание всех параметров библиотеки](#описание-всех-параметров-библиотеки)
- [Список предопределенных хранилищ токенов](#список-предопределенных-хранилищ-токенов)
- [Создание своего хранилища токенов](#создание-своего-хранилища-токенов)
- [Смена хранилища токенов в рантайме](#смена-хранилища-токенов-в-рантайме)
- [Troubleshooting](#troubleshooting)

## Описание

Данная библиотека реализует управление аутентификацией на сайте. 

Позволяет:
- выбирать где будут храниться токены, выбирая хранилище токенов (подробнее далее);
- изменять хранилища токенов прямо в рантайме (подробнее далее);
- создать свое кастомное хранилище токенов (подробнее далее);
- автоматически обновлять токен доступа (access token). Обновление происходит либо по истечению срока валидности токена доступа, либо указать коэффициент протухания токена `refreshThreshold` по достижению которого будет выполнено обновление токена, для этих целей используется interceptor [JwtAuthInterceptor](../../projects/ngx-jwt-auth/src/lib/interceptors/jwt-auth.interceptor.ts).
- ограничивать доступ на определенные роуты для не авторизованных пользователей, используя [AuthGuard](../../projects/ngx-jwt-auth/src/lib/guards/auth.guard.ts);
- ограничивать доступ на определенные роуты для авторизованных пользователей, используя [UnAuthGuard](../../projects/ngx-jwt-auth/src/lib/guards/un-auth.guard.ts);
- подписаться на поток `isLoggedIn$`, в котором храниться текущий статус аутентификации пользователя [JwtAuthService](../../projects/ngx-jwt-auth/src/lib/services/jwt-auth.service.ts);
- самому управлять токенами (получит, удалить, сохранить токен) через сервис [AuthTokenManager](../../projects/ngx-jwt-auth/src/lib/services/auth-token-manager.service.ts);
- управлять не только авторизационнами токенами, а любыми другими JWT токенами для этих целей выделены отдельные настройки в `JwtAuthModule`, отдельное хранилище токенов (можно использовать те же предопределенные хранилища, либо создать свое), отдельный сервис для работы с токенами [TokenManager](../../projects/ngx-jwt-auth/src/lib/services/token-manager.service.ts) и отдельный сервис для управления хранилищем токенов [TokenStorageManager](../../projects/ngx-jwt-auth/src/lib/services/token-storage-manager.service.ts).
- расширить базовые возможности путем создания кастомных хранилищ токенов, кастомных решений для управления токенами (расширить [BaseTokenManager](../../projects/ngx-jwt-auth/src/lib/services/base-token-manager.ts)) и хранилищами токенов (расширить [BaseTokenStorageManager](../../projects/ngx-jwt-auth/src/lib/services/base-token-storage-manager.ts)).

## Настройка и применение
1. Импортировать `JwtAuthModule` в root/core модуль вашего приложения с вызовом метода `forRoot`, и в данный метод передать параметры:

```typescript
import { JwtAuthModule } from '@dekh/ngx-jwt-auth';

@NgModule({
  imports: [
    JwtAuthModule.forRoot(options),
  ],
})
export class AppModule {}
```

2. Необходимо создать Api-сервис, реализуя базовый класс [BaseAuthApiService](../../projects/ngx-jwt-auth/src/lib/services/base-auth-api-service.ts). Данный класс обязует реализовать 3 метода `login`, `logout` и `refresh`. Методы `login` и `refresh` должны возвращать Observable cо значение `{ accessToken: string; refreshToken?: string; }`, если ваш сервер в методе авторизации `login` и\или в методе  обновления токена доступа `refresh` возвращает другой формат, то достаточно просто можно смаппить значение оператором `map` из rxjs в нужный формат. Пример такого сервиса:

```typescript
@Injectable({
	providedIn: 'root',
})
export class AuthApiService extends BaseAuthApiService {
  constructor(private readonly _httpClient: HttpClient) {
    super();
  }

  // Данный метод возвращает AuthResponseTokens который имеет структуру
  // { accessToken: string; refreshToken?: string; }, 
  // поэтому маппить ничего не нужно!
  public login(credentials: Login): Observable<AuthResponseTokens> {
    return this._httpClient.post<AuthResponseTokens>(
      environments.apiUrl + '/auth/login',
      credentials,
      { withCredentials: true }
    );
  }

  public logout(): Observable<void> {
    return this._httpClient.post<void>(environments.apiUrl + '/auth/logout', null, {
      withCredentials: true,
    });
  }

  // Так как данный метод не возвращает с сервера нужную нам модель,
  // то мы ее с помощью оператора map маппим в { accessToken: string; refreshToken?: string; }
  public refresh(): Observable<RefreshTokenResponse> {
    return this._httpClient.post<RefreshTokenResponse>(environments.apiUrl + '/auth/refresh', null, {
      withCredentials: true,
    }).pipe(
      map((res) => ({
        accessToken: res.tokens.newAccessToken,
        refreshToken: res.tokens.newRefreshToken,
      }))
    );
  }

  public register(credentials: Registration): Observable<void> {
    return this._httpClient.post<void>(environments.apiUrl + '/auth/register', credentials);
  }
}
```

3. Далее нужно передать в параметры `JwtAuthModule.forRoot(options)` обязательные параметры:

```typescript
import {
  JwtAuthModule,
  InMemoryTokenStorage,
  LocalStorageTokenStorage
} from '@dekh/ngx-jwt-auth';
import { AuthApiService } from '../services';

@NgModule({
  imports: [
    JwtAuthModule.forRoot({
      // Наш ранее созданный AuthApiService
      authApiService: AuthApiService,
      tokenStorage: LocalStorageTokenStorage,
      authTokenStorage: InMemoryTokenStorage,
    }),
  ],
})
export class AppModule {}
```

4. Запровайдить Interceptor [JwtAuthInterceptor](../../projects/ngx-jwt-auth/src/lib/interceptors/jwt-auth.interceptor.ts).

> `JwtAuthInterceptor` реализует механизм обновления токена доступа путем проверки валидности токена и порога валидности `refreshTreshold` перед каждым запросом за исключением url запросов, которые указаны в параметре `unsecuredUrls`. Если токен не валиден, то будет произведена попытка обновления токена с последующим выполнением оригинального запроса, но если токен не сможет обновиться тогда пользователя разлогинет методом `logout` из `BaseAuthApiService`. 

> Не обязательное использовать `JwtAuthInterceptor`, можно реализовать собственный механизм перехвата запросов с последущим обновлением токена доступа.

Пример:

```typescript
import {
  JwtAuthModule,
  InMemoryTokenStorage,
  LocalStorageTokenStorage,
  JwtAuthInterceptor
} from '@dekh/ngx-jwt-auth';
import { AuthApiService } from '../services';

@NgModule({
  imports: [
    JwtAuthModule.forRoot({
      authApiService: AuthApiService,
      tokenStorage: LocalStorageTokenStorage,
      authTokenStorage: InMemoryTokenStorage,
    }),
  ],
  providers: [
    {
      provide: HTTP_INTERCEPTORS,
      useClass: JwtAuthInterceptor,
      multi: true,
    },
  ],
})
export class AppModule {}
```

5. Если в приложении нам нужно выполнить авторизацию или разлогиниться, то мы должны использовать proxy сервис `JwtAuthService`, который под капотом вызывает методы из нашего `AuthApiService` сервиса и выполняет дополнительные действия - сохраняет accessToken и refreshToken в хранилище, обновляет статус авторизации в `isLoggedIn$`.

Например:

На форме авторизации при ее отправки нужно использовать `JwtAuthService` и вызывать метод `login(...args[]: any)` все перданные аргументы в данный метод будут прокинуты в метод `login(...args[]: any)` нашего ранее созданного Api-сервиса для авторизации `AuthApiService` (все параметры прокидываются для каждого метода определенного в `BaseAuthApiService`):

```typescript
@Component({
  selector: 'app-login',
  templateUrl: './login.component.html',
  styleUrls: ['./login.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class LoginComponent implements OnDestroy {
  public form: FormGroup;

  private readonly _isLoading$ = new BehaviorSubject<boolean>(false);
  public readonly isLoading$ = this._isLoading$.asObservable();

  private readonly _loginError$ = new BehaviorSubject<string | null>(null);
  public readonly loginError$ = this._loginError$.asObservable();

  private readonly _destroy$ = new Subject<void>();

  constructor(
    private readonly _fb: FormBuilder,
    private readonly _jwtAuthService: JwtAuthService, 
  ) {
    this._createForm();
  }

  public ngOnDestroy(): void {
    this._destroy$.next();
    this._destroy$.complete();
  }

  public login(): void {
    this._isLoading$.next(true);

    // Login class it`s Domain model
    const credentials = new Login(this.form.value);

    this._authService
      .login(credentials)
      .pipe(
        tap(() => this._loginError$.next(null)),
        catchError((error: HttpError<ServerErrorDto>) => {
          this._loginError$.next(error.error.message);
          return EMPTY;
        }),
        finalize(() => this._isLoading$.next(false))
      )
      .subscribe();
  }

  private _createForm(): void {
    this.form = this._fb.group({
      email: [null, [Validators.required, Validators.email]],
      password: [null, [Validators.required]],
    });
  }
}
```

6. Ограничить доступ на роуты, на которые может заходить только авторизованный пользователь или наоборот только не авторизованный.
На примере ниже на страницу `/auth/login` и `/auth/registration` может зайти только не авторизованный пользователь, а открыть страницу `/dashboard` может только авторизованный:

```typescript
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { AuthGuard, UnAuthGuard } from '@dekh/ngx-jwt-auth';
import { LoginComponent, RegistrationComponent } from '../auth';
import { DashboardComponent } from '../dashboard';

const routes: Routes = [
  {
    path: 'auth',
    children: [
      {
        path: 'login',
        component: LoginComponent,
        canActivate: [UnAuthGuard],
      },
      {
        path: 'registration',
        component: RegistrationComponent,
        canActivate: [UnAuthGuard],
      },
    ],
  },
  {
    path: 'dashboard',
    component: DashboardComponent,
    canActivate: [AuthGuard],
  },
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule],
})
export class AppRoutingModule {}
```

## Описание всех параметров библиотеки
- `authApiService: Type<BaseAuthApiService>` - Класс реализующий BaseAuthApiService и выполняющий запросы к серверу.

- `tokenStorage: Type<BaseTokenStorage>` - Хранилище обычных jwt токенов (не авторизационных).

- `authTokenStorage: Type<BaseTokenStorage>` - Хранилище авторизационных токенов.

- `authHeaderName?: string` - Название Http Header который будет использоваться для авторизации. By default `Authorization`.

- `authScheme?: string` - Префикс в значении Http Header определяющее схему авторизации. By default `Bearer`.

- `tokenExpField?: string` - Поле в payload токена, в котором храниться timestamp когда токен просрочиться. By default `exp`.

- `tokenIatField?: string` - Поле в payload токена, в котором храниться timestamp когда токен был выпущен. By default `iat`.

- `customTokenStorages?: BaseTokenStorage[]` - Массив кастомных (пользовательских) хранилищ токена. By default empty array `[]`.

- `unsecuredUrls?: string[]` - Массив URL и Path, которые не будут обрабатываться AuthInterceptor'ом. т.е. на указанных URL и Path не будет проверяться access token и выполнятся обновление access token'а если он истек. By default empty array `[]`.
  > **Важно:** указывайте ваши URL для авторизации, например `http://localhost:5000/auth` или часть URL - `/auth/refresh`,`/auth/login`, `/auth/registration` или все URL для аутентификации `/auth`, чтобы избежать бесконечно рекурсивного вызова обновления токена при выдаче 401 статус кода.

  > **Важно:** всегда указывайте URL для обновления токена, иначе будет циркулярная зависимость:
  >> ERROR Error: NG0200: Circular dependency in DI detected for JwtAuthService.
  >
  > Это происходит потому что `HttpClient` зависит от `Interceptor (JwtAuthInterceptor)` зависит от `AuthApiService` зависит от `HttpClient`.
  > 
  > [Способ исправления данной ошибки здесь.](#troubleshooting)

- `refreshThreshold?: number` - Коэффициент порога обновления токена, если expireIn access token'а приблизиться к данному коэффициенту, то будет произведен рефреш токена. By default `0.8`.

- `saveRefreshTokenInStorage?: boolean` - Сохранять ли refresh token который приходит при авторизации и/или при обновлении токена. By default `false`.
  > Стоит включать данную опцию только если сервер не сохраняет refresh token в cookie, тогда для обновления токена нужно его передавать в запрос на обновление, а хранить придется на клиенте, что изначально является плохой практикой и может привести к проблемам в защите приложения путем кражи злоумышленником access и refresh токенов.

  > **Важно:** если данная опция включена, то следует сменить `authTokenStorage` с `InMemoryTokenStorage` на любой другой предопределенный или кастомный `TokenStorage`. Если этого не сделать, то пользователю придется каждый раз логинится при обновлении страницы, так как при обновлении страницы будет очищатся память и соответственно `InMemoryTokenStorage`, так устроен JS.

- `unAuthGuardRedirectUrl?: string` - URL куда будет редиректить авторизованного пользователя, если он попробует зайти на route защищенный UnAuthGuard. Если не задать значение, то route защищенный UnAuthGuard будут просто отклонять переход на данный route.

- `authGuardRedirectUrl?: string` - URL куда будет редиректить не авторизованного пользователя, если он попробует зайти на route защищенный AuthGuard. Если не задать значение, то route защищенный AuthGuard будут просто отклонять переход на данный route.

## Список предопределенных хранилищ токенов

- `CookiesTokenStorage` - абстракция над cookies, сохраняет токены в cookies;
- `LocalStorageTokenStorage` - абстракция над localStorage, сохраняет токены в localStorage;
- `SessionStorageTokenStorage` - абстракция над sessionStorage, сохраняет токены в sessionStorage;
- `InMemoryTokenStorage` - сохраняет токены в памяти приложения, есть свои недостатки, при использовании данного хранилища для авторизационных токенов после перезагрузки страницы будет выполнен запрос на обновление токена доступа (для SPA приложений это не критично), но зато самое безопасное хранилище для авторизационных токенов;

## Создание своего хранилища токенов

Для того чтобы создать свое хранилище токенов достаточно реализовать базовый класс [BaseTokenStorage](../../projects/ngx-jwt-auth/src/lib/token-storages/base-token-storage.ts) и указать в параметре `customTokenStorages` модуля `JwtAuthModule.forRoot()` массив кастомных хранилище токенов. Пример:

```typescript
// my-custom-token-storage.ts
import { BaseTokenStorage } from '@dekh/ngx-jwt-auth';

export class MyCustomTokenStorage extends BaseTokenStorage {
  public get(key: string): string | null {
    // custom realisation
  }

  public set(key: string, token: string): void {
    // custom realisation
  }

  public delete(key: string): void {
    // custom realisation
  }

  // можем переопределить метод для проверки валидности токенами
  // но делать это не рекомендуется!
  public override isValid(key: string): boolean {
    // super.isValid();
    // custom realisation
  }
}
```

Определяем наше хранилище в параметрах модуля `JwtAuthModule`:

```typescript
// app.module.ts
import { JwtAuthModule } from '@dekh/ngx-jwt-auth';
import { MyCustomTokenStorage } from '../auth';

@NgModule({
  imports: [
    JwtAuthModule.forRoot({
      customTokenStorages: [new MyCustomTokenStorage()],
    }),
  ],
})
export class AppModule {}
```

Либо мы можем зарегистрировать наше хранилище посредством сервиса `TokenStorageRegistry`:

```typescript
// app.service.ts
import {
  LocalStorageTokenStorage,
  InMemoryTokenStorage,
  TokenStorageRegistry
} from '@dekh/ngx-jwt-auth';
import { AuthApiService } from '../services';
import { MyCustomTokenStorage } from '../auth';

@NgModule({
  imports: [
    JwtAuthModule.forRoot({
      authApiService: AuthApiService,
      tokenStorage: LocalStorageTokenStorage,
      authTokenStorage: InMemoryTokenStorage,
    }),
  ],
})
export class AppModule {
  constructor(private readonly _tokenStorageRegistry: TokenStorageRegistry) {
    this._tokenStorageRegistry.register(new MyCustomTokenStorage());
  }
}
```

## Смена хранилища токенов в рантайме

В редких случаях может понадобится в рантайме изменить хранилище токенов, для этого существует два сервиса [TokenStorageManager](../../projects/ngx-jwt-auth/src/lib/services/token-storage-manager.service.ts) и [AuthTokenStorageManager](../../projects/ngx-jwt-auth/src/lib/services/auth-token-storage-manager.service.ts), оба этих сервиса имеют одинаковый интерфейс взаимодествия. `TokenStorageManager` используется для управление хранилищем __не авторизационных__ токенов, а `AuthTokenStorageManager` для управление хранилищем __авторизационных__ токенов. 

Пример:

```typescript
// token-storage-changer.service.ts
import {
  AuthTokenStorageManager,
  TokenStorageRegistry,
  CookiesTokenStorage,
  BaseTokenStorage,
} from '@dekh/ngx-jwt-auth';
import { MyCustomTokenStorage } from '../auth';

@Injectable({
  provideIn: 'root'
})
export class TokenStorageChangerService {
  constructor(
    private readonly _authTokenStorageManager: AuthTokenStorageManager,
    private readonly _tokenStorageRegistry: TokenStrageRegistry,
  ) {
    this._tokenStorageRegistry.register(new MyCustomTokenStorage());
  }

  public setMyCustomStorage(): void {
    if (!this._tokenStorageRegistry.isRegistered(MyCustomTokenStorage)) {
      throw new Error('MyCustomTokenStorage is not registered!'); 
    }

    const myCustomStorage = this._tokenStorageRegistry.get(MyCustomTokenStorage);
    // or
    // const myCustomStorage = this._tokenStorageRegistry.get(new MyCustomTokenStorage());
    // or
    // const myCustomStorage = this._tokenStorageRegistry.get('MyCustomTokenStorage');
    this.changeAuthStorage(myCustomStorage);
  }

  public setCookiesStorage(): void {
    const cookiesStorage = this._tokenStorageRegistry.get(CookiesTokenStorage);
    // or
    // const cookiesStorage = this._tokenStorageRegistry.get(new CookiesTokenStorage());
    // or
    // const cookiesStorage = this._tokenStorageRegistry.get('CookiesTokenStorage');
    this.changeAuthStorage(storage);
  }

  public changeAuthStorage(storage: BaseTokenStorage): void {
    this._authTokenStorageManager.setStorage(storage);
  }
}
```

## Troubleshooting

- При старте приложения выдает ошибку __"ERROR Error: NG0200: Circular dependency in DI detected for JwtAuthService."__

  Причинной данной обишбки - цикличный вызов `JwtAuthInterceptor`. Так как interceptor обработавыает каждый запрос, за исключением тех зопросов url которые указаны в параметре конфига `unsecuredUrls`, запрос на обновление токена создает цикличную зависимость.

  Решением данной проблемы является указать в массиве `unsecuredUrls` URL или path запроса на обновление accessToken'а, либо указать корневой path для всех запросов связанных с авторизацией/регистрацией пользователя, например: `"/auth/"`, тогда все запросы c path auth будут исключены из проверки interceptor'a - `server.api/auth/login`, `server.api/auth/register`, `server.api/auth/refresh` и подобные.