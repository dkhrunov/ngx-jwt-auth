# Ngx JWT Auth
<a href="https://jwt.io/">
  <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:sketch="http://www.bohemiancoding.com/sketch/ns" width="144px" height="36px" viewBox="0 0 144 36" version="1.1">
    <title>Compatible</title>
    <desc>Created with Sketch.</desc>
    <defs/>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" sketch:type="MSPage">
        <g id="Artboard-8" sketch:type="MSArtboardGroup" transform="translate(-311.000000, -287.000000)">
            <g id="Compatible" sketch:type="MSLayerGroup" transform="translate(311.000000, 287.000000)">
                <rect id="Rectangle-237" fill="#000000" sketch:type="MSShapeGroup" x="0" y="0" width="144" height="35.8015267" rx="18"/>
                <g id="Group-Copy-5" transform="translate(8.419260, 8.479309)" sketch:type="MSShapeGroup">
                    <g id="Group-Copy-4">
                        <path d="M10.8773693,5.08758538 L10.8773693,-1.33226763e-15 L8.04472108,-1.33226763e-15 L8.04472108,5.08758538 L9.44216089,7.00956207 L10.8773693,5.08758538 Z" id="Shape" fill="#FFFFFF"/>
                        <path d="M8.04472108,13.7553234 L8.04472108,18.8429088 L10.8773693,18.8429088 L10.8773693,13.7553234 L9.44216089,11.8333467 L8.04472108,13.7553234 Z" id="Shape" fill="#FFFFFF"/>
                        <path d="M10.8773693,13.7553234 L13.8610922,17.8630775 L16.1272108,16.2049016 L13.143488,12.0971474 L10.8773693,11.3811169 L10.8773693,13.7553234 Z" id="Shape" fill="#00F2E6"/>
                        <path d="M8.04472108,5.08758538 L5.02322959,0.979831258 L2.75711098,2.63800723 L5.74083382,6.74576135 L8.04472108,7.46179188 L8.04472108,5.08758538 Z" id="Shape" fill="#00F2E6"/>
                        <path d="M5.74083382,6.74576135 L0.906447446,5.16295701 L0.0377686436,7.83865006 L4.87215502,9.4214544 L7.13827363,8.66773805 L5.74083382,6.74576135 Z" id="Shape" fill="#00B9F1"/>
                        <path d="M11.7460482,10.1751708 L13.143488,12.0971474 L17.9778743,13.6799518 L18.8465531,11.0042587 L14.0121668,9.4214544 L11.7460482,10.1751708 Z" id="Shape" fill="#00B9F1"/>
                        <path d="M14.0121668,9.4214544 L18.8465531,7.83865006 L17.9778743,5.16295701 L13.143488,6.74576135 L11.7460482,8.66773805 L14.0121668,9.4214544 Z" id="Shape" fill="#D63AFF"/>
                        <path d="M4.87215502,9.4214544 L0.0377686436,11.0042587 L0.906447446,13.6799518 L5.74083382,12.0971474 L7.13827363,10.1751708 L4.87215502,9.4214544 Z" id="Shape" fill="#D63AFF"/>
                        <path d="M5.74083382,12.0971474 L2.75711098,16.2049016 L5.02322959,17.8630775 L8.04472108,13.7553234 L8.04472108,11.3811169 L5.74083382,12.0971474 Z" id="Shape" fill="#FB015B"/>
                        <path d="M13.143488,6.74576135 L16.1272108,2.63800723 L13.8610922,0.979831258 L10.8773693,5.08758538 L10.8773693,7.46179188 L13.143488,6.74576135 Z" id="Shape" fill="#FB015B"/>
                    </g>
                </g>
                <path d="M38.8776319,19.767424 L38.8776319,13.8922242 L37.3265792,13.8922242 L37.3265792,19.5676672 C37.3265792,20.4371968 36.8918144,20.766208 36.17504,20.766208 C35.7520256,20.766208 35.5052672,20.7192064 35.2467584,20.648704 L35.4582656,22 C35.6580224,22.0352512 36.0222848,22.0822528 36.3865472,22.0822528 C37.8435967,22.0822528 38.8776319,21.41248 38.8776319,19.767424 L38.8776319,19.767424 Z M51.1450493,13.8922242 L49.5822461,13.8922242 L48.1016957,19.6146688 L46.4096382,13.8922242 L44.846835,13.8922242 L43.1547774,19.6146688 L41.6272255,13.8099714 L40.0056703,14.1037314 L42.2734975,22 L43.7422974,22 L45.5401086,16.1012993 L47.3379198,22 L48.8184701,22 L51.1450493,13.8922242 Z M58.3127931,15.2435201 L58.0895355,13.8922242 L51.7913213,13.8922242 L51.7913213,15.2435201 L54.2001532,15.2435201 L54.2001532,22 L55.7629564,22 L55.7629564,15.2435201 L58.3127931,15.2435201 Z M67.8423673,21.4477312 L67.6308602,20.1081856 C67.008089,20.5194496 66.3265658,20.7897088 65.5745402,20.7897088 C64.1409914,20.7897088 63.2009594,19.7321728 63.2009594,17.9461121 C63.2009594,16.1835521 64.0822394,15.0907649 65.5157882,15.0907649 C66.303065,15.0907649 66.9610874,15.4080257 67.4898554,15.8075393 L67.713113,14.3387394 C67.1138426,13.974477 66.3853178,13.7512194 65.4452858,13.7512194 C63.1539578,13.7512194 61.6146555,15.4432769 61.6146555,17.9578625 C61.6146555,20.472448 63.0952058,22.1410048 65.4570362,22.1410048 C66.3735674,22.1410048 67.1960954,21.8589952 67.8423673,21.4477312 L67.8423673,21.4477312 Z M76.1969016,17.9343617 C76.1969016,15.4315265 74.7281016,13.739469 72.4015225,13.739469 C70.0866937,13.739469 68.5826425,15.4432769 68.5826425,17.9578625 C68.5826425,20.4606976 70.0749433,22.1527552 72.3780217,22.1527552 C74.7046008,22.1527552 76.1969016,20.4371968 76.1969016,17.9343617 L76.1969016,17.9343617 Z M74.622348,17.9461121 C74.622348,19.7204224 73.7880696,20.8602112 72.3897721,20.8602112 C71.0032249,20.8602112 70.1689465,19.7204224 70.1689465,17.9461121 C70.1689465,16.1718017 71.0032249,15.0320129 72.3897721,15.0320129 C73.7763192,15.0320129 74.622348,16.1718017 74.622348,17.9461121 L74.622348,17.9461121 Z M86.6312566,22 L86.0084854,13.8922242 L84.0696694,13.8922242 L82.0250999,20.0141824 L79.9687799,13.8922242 L77.9947127,13.8922242 L77.3719416,22 L78.7702391,22 L79.1815031,16.0777985 L81.2378231,22.0235008 L82.6008695,22.0235008 L84.645439,16.0777985 L85.0802038,22 L86.6312566,22 Z M93.4582388,16.3833089 C93.4582388,14.7500033 92.3419509,13.8922242 90.4853877,13.8922242 L88.1118069,13.8922242 L88.1118069,22 L89.6628597,22 L89.6628597,19.0153985 L90.3561333,19.0153985 C92.2126965,19.0153985 93.4582388,18.1341185 93.4582388,16.3833089 L93.4582388,16.3833089 Z M91.9306869,16.4185601 C91.9306869,17.3468417 91.3431669,17.7581057 90.3443829,17.7581057 L89.6628597,17.7581057 L89.6628597,15.1377665 L90.4031349,15.1377665 C91.4019189,15.1377665 91.9306869,15.5725313 91.9306869,16.4185601 L91.9306869,16.4185601 Z M100.896242,21.8002432 L97.9233907,13.856973 L96.2665844,13.856973 L93.2232308,22 L94.7625332,22 L95.5028084,19.94368 L98.5696627,19.94368 L99.3451891,22.0822528 L100.896242,21.8002432 Z M98.1348979,18.6746369 L95.9258228,18.6746369 L97.0303604,15.5490305 L98.1348979,18.6746369 Z M106.994699,15.2435201 L106.771442,13.8922242 L100.473227,13.8922242 L100.473227,15.2435201 L102.882059,15.2435201 L102.882059,22 L104.444863,22 L104.444863,15.2435201 L106.994699,15.2435201 Z M109.720792,22 L109.720792,13.8922242 L108.157989,13.8922242 L108.157989,22 L109.720792,22 Z M116.865035,19.6381696 C116.865035,18.5571329 116.265765,17.9696129 115.360984,17.6876033 C116.066008,17.3938433 116.536024,16.8415745 116.536024,15.9955457 C116.536024,14.7147521 115.666494,13.8922242 113.845182,13.8922242 L111.483352,13.8922242 L111.483352,22 L113.809931,22 C115.713496,22 116.865035,21.236224 116.865035,19.6381696 L116.865035,19.6381696 Z M115.090725,16.1248001 C115.090725,16.8180737 114.608958,17.2293377 113.692427,17.2293377 L112.975653,17.2293377 L112.975653,15.0790145 L113.76293,15.0790145 C114.702962,15.0790145 115.090725,15.4785281 115.090725,16.1248001 L115.090725,16.1248001 Z M115.372734,19.591168 C115.372734,20.4019456 114.796965,20.8132096 113.809931,20.8132096 L112.975653,20.8132096 L112.975653,18.3338753 L113.78643,18.3338753 C114.820466,18.3338753 115.372734,18.7686401 115.372734,19.591168 L115.372734,19.591168 Z M122.610981,22 L122.399473,20.6252032 L119.696882,20.6252032 L119.696882,13.8922242 L118.134078,13.8922242 L118.134078,22 L122.610981,22 Z M128.568433,22 L128.568433,20.6839552 L125.278321,20.6839552 L125.278321,18.4513793 L127.933912,18.4513793 L127.722405,17.1118337 L125.278321,17.1118337 L125.278321,15.2082689 L128.450929,15.2082689 L128.450929,13.8922242 L123.739019,13.8922242 L123.739019,22 L128.568433,22 Z" id="Type-something" fill="#FFFFFF" sketch:type="MSShapeGroup"/>
            </g>
        </g>
    </g>
  </svg>
</a>

<br/>

A library for Token-Based Authentication (JWT Authentication).

This library is configurable for any use cases.

## Other languages
- [Russian](./src/doc/ru/README.md)

## Content
- [Description](#description)
- [Setup and use](#setup-and-use)
- [Description of all library parameters](#description-of-all-library-parameters)
- [List of predefined Token Storages](#list-of-predefined-token-storages)
- [Creating your own Token Storage](#creating-your-own-token-storage)
- [Changing token storage at runtime](#changing-token-storage-at-runtime)
- [Troubleshooting](#troubleshooting)

## Description

This library implements the main features and basic requirements for Token-Based Authentication in an Angular application.

Features:
- choose where tokens will be stored by choosing a token storage;
- change the storage of tokens directly in runtime;
- create your own custom storage of tokens;
- automatically refresh the access token. Refresh occurs either after the validity period of the access token expires, or specify the `refreshThreshold` token decay coefficient, upon reaching which the token will be updated, for these purposes the interceptor [JwtAuthInterceptor](./src/lib/interceptors/jwt-auth.interceptor.ts) is used).
- restrict access to certain routes for unauthorized users using [AuthGuard](./src/lib/guards/auth.guard.ts);
- restrict access to certain routes for authorized users using [UnAuthGuard](./src/lib/guards/un-auth.guard.ts);
- subscribe to the `isLoggedIn$` stream, which stores the current user authentication status [JwtAuthService](./src/lib/services/jwt-auth.service.ts);
- manage tokens yourself (get, delete, save a token) through the service [AuthTokenManager](./src/lib/services/auth-token-manager.service.ts);
- manage not only authorization tokens, but any other JWT tokens for these purposes, there are separate settings in `JwtAuthModule`, a separate token storage (you can use the same predefined storages, or create your own), a separate service for working with tokens [TokenManager] (. /src/lib/services/token-manager.service.ts) and a separate service for managing token storage [TokenStorageManager](./src/lib/services/token-storage-manager.service.ts).
- extend the basic features by creating custom token stores, custom token management solutions (extend [BaseTokenManager](./src/lib/services/base-token-manager.ts)) and token stores (extend [BaseTokenStorageManager](./src /lib/services/base-token-storage-manager.ts)).

## Setup and use
1. Import `JwtAuthModule` into the App/Core module of your application with a call to the `forRoot` method, and pass parameters to this method:

```typescript
import { JwtAuthModule } from '@dekh/ngx-jwt-auth';

@NgModule({
  imports: [
    JwtAuthModule.forRoot(options),
  ],
})
export class AppModule {}
```

2. You need to create an Api-service by implementing the [BaseAuthApiService](./src/lib/services/base-auth-api-service.ts) base class. This class obliges to implement 3 methods `login`, `logout` and `refresh`. The `login` and `refresh` methods must return an Observable with the value `{ accessToken: string; refreshToken?: string; }`, if your server in the `login` authorization method and\or in the `refresh` access token refresh method returns a different format, then it is quite easy to map the value with the `map` operator from rxjs to the desired format. An example of such a service:

```typescript
@Injectable({
	providedIn: 'root',
})
export class AuthApiService extends BaseAuthApiService {
  constructor(private readonly _httpClient: HttpClient) {
    super();
  }

  // This method returns AuthResponseTokens which has the structure
  // { accessToken: string; refreshToken?: string; }, so you don't need to map anything!
  public login(credentials: Login): Observable<AuthResponseTokens> {
    return this._httpClient.post<AuthResponseTokens>(
      environments.apiUrl + '/auth/login',
      credentials,
      { withCredentials: true }
    );
  }

  public logout(): Observable<void> {
    return this._httpClient.post<void>(environments.apiUrl + '/auth/logout', null, {
      withCredentials: true,
    });
  }

  // Since this method does not return the model we need from the server,
  // we map it using the map operator in { accessToken: string; refreshToken?: string; }
  public refresh(): Observable<RefreshTokenResponse> {
    return this._httpClient.post<RefreshTokenResponse>(environments.apiUrl + '/auth/refresh', null, {
      withCredentials: true,
    }).pipe(
      map((res) => ({
        accessToken: res.tokens.newAccessToken,
        refreshToken: res.tokens.newRefreshToken,
      }))
    );
  }

  public register(credentials: Registration): Observable<void> {
    return this._httpClient.post<void>(environments.apiUrl + '/auth/register', credentials);
  }
}
```

3. Next, you need to pass the required parameters to the `JwtAuthModule.forRoot(options)` parameters:

```typescript
import {
  JwtAuthModule,
  InMemoryTokenStorage,
  LocalStorageTokenStorage
} from '@dekh/ngx-jwt-auth';
import { AuthApiService } from '../services';

@NgModule({
  imports: [
    JwtAuthModule.forRoot({
      // Our previously created AuthApiService
      authApiService: AuthApiService,
      tokenStorage: LocalStorageTokenStorage,
      authTokenStorage: InMemoryTokenStorage,
    }),
  ],
})
export class AppModule {}
```

4. Provide Interceptor [JwtAuthInterceptor](./src/lib/interceptors/jwt-auth.interceptor.ts).

> `JwtAuthInterceptor` implements an access token refresh mechanism by checking the validity of the token and the `refreshTreshold` validity threshold before each request, except for requests whose URL is specified in the `unsecuredUrls` parameter. If the token is not valid, then an attempt will be made to refresh the token followed by the original request, but if the token cannot be refreshed, then the user will be logged out using the `logout` method from `BaseAuthApiService`. 

> It is not mandatory to use `JwtAuthInterceptor`, you can implement your own mechanism for intercepting requests with subsequent refresh of the access token.

Example:

```typescript
import {
  JwtAuthModule,
  InMemoryTokenStorage,
  LocalStorageTokenStorage,
  JwtAuthInterceptor
} from '@dekh/ngx-jwt-auth';
import { AuthApiService } from '../services';

@NgModule({
  imports: [
    JwtAuthModule.forRoot({
      authApiService: AuthApiService,
      tokenStorage: LocalStorageTokenStorage,
      authTokenStorage: InMemoryTokenStorage,
    }),
  ],
  providers: [
    {
      provide: HTTP_INTERCEPTORS,
      useClass: JwtAuthInterceptor,
      multi: true,
    },
  ],
})
export class AppModule {}
```

5. If in the application we need to get authorization or log out, then we must use the `JwtAuthService` proxy service, which under the hood offers methods from our `AuthApiService` service, and performs additional actions - saves accessToken and refreshToken in storage, updates the authorization status in ` isLoggedIn$`.

Example:

On the authorization form, when sending it, you need to use `JwtAuthService` and call the `login(...args[]: any)` method; all arguments passed to this method will be passed to the `login(...args[]: any)` method our previously created Api-service for authorization `AuthApiService` (all parameters are passed for each method defined in `BaseAuthApiService`):

```typescript
@Component({
  selector: 'app-login',
  templateUrl: './login.component.html',
  styleUrls: ['./login.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class LoginComponent implements OnDestroy {
  public form: FormGroup;

  private readonly _isLoading$ = new BehaviorSubject<boolean>(false);
  public readonly isLoading$ = this._isLoading$.asObservable();

  private readonly _loginError$ = new BehaviorSubject<string | null>(null);
  public readonly loginError$ = this._loginError$.asObservable();

  private readonly _destroy$ = new Subject<void>();

  constructor(
    private readonly _fb: FormBuilder,
    private readonly _jwtAuthService: JwtAuthService, 
  ) {
    this._createForm();
  }

  public ngOnDestroy(): void {
    this._destroy$.next();
    this._destroy$.complete();
  }

  public login(): void {
    this._isLoading$.next(true);

    // Login class it`s Domain model
    const credentials = new Login(this.form.value);

    this._authService
      .login(credentials)
      .pipe(
        tap(() => this._loginError$.next(null)),
        catchError((error: HttpError<ServerErrorDto>) => {
          this._loginError$.next(error.error.message);
          return EMPTY;
        }),
        finalize(() => this._isLoading$.next(false))
      )
      .subscribe();
  }

  private _createForm(): void {
    this.form = this._fb.group({
      email: [null, [Validators.required, Validators.email]],
      password: [null, [Validators.required]],
    });
  }
}
```

6. Restrict access to routes that can only be accessed by an authorized user or vice versa only by an unauthorized user.
In the example below, only an unauthorized user can access the `/auth/login` and `/auth/registration` pages, and only an authorized user can open the `/dashboard` page:

```typescript
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { AuthGuard, UnAuthGuard } from '@dekh/ngx-jwt-auth';
import { LoginComponent, RegistrationComponent } from '../auth';
import { DashboardComponent } from '../dashboard';

const routes: Routes = [
  {
    path: 'auth',
    children: [
      {
        path: 'login',
        component: LoginComponent,
        canActivate: [UnAuthGuard],
      },
      {
        path: 'registration',
        component: RegistrationComponent,
        canActivate: [UnAuthGuard],
      },
    ],
  },
  {
    path: 'dashboard',
    component: DashboardComponent,
    canActivate: [AuthGuard],
  },
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule],
})
export class AppRoutingModule {}
```

## Description of all library parameters
- `authApiService: Type<BaseAuthApiService>` - A class that implements `BaseAuthApiService` and makes requests to the server.

- `tokenStorage: Type<BaseTokenStorage>` - Storage of regular jwt tokens (not authorization ones).

- `authTokenStorage: Type<BaseTokenStorage>` - Storage of authorization tokens.

- `authHeaderName?: string` - The name of the Http Header that will be used for authorization. By default `Authorization`.

- `authScheme?: string` - A prefix in the Http Header value that defines the authorization scheme. By default `Bearer`.

- `tokenExpField?: string` - The field in the payload of the token, in which the timestamp is stored when the token expires. By default `exp`.

- `tokenIatField?: string` - A field in the payload of the token that stores the timestamp when the token was issued. By default `iat`.

- `customTokenStorages?: BaseTokenStorage[]` - An array of custom (custom) token storages. By default empty array `[]`.

- `unsecuredUrls?: string[]` - An array of URLs and Paths that will not be processed by the AuthInterceptor. those. the access token will not be checked on the specified URL and Path and the access token will be updated if it has expired. By default empty array `[]`.
  > **Notice:** specify your URL for authorization, for example `http://localhost:5000/auth` or part of the URL - `/auth/refresh`,`/auth/login`, `/auth/registration` or all URLs for authentication `/auth ` to avoid an infinitely recursive token refresh call when a 401 status code is issued.

  > **Notice:** always specify the URL for updating the token, otherwise there will be a circular dependency:
  >> ERROR Error: NG0200: Circular dependency in DI detected for JwtAuthService.
  >
  > This is because `HttpClient` depends on `Interceptor (JwtAuthInterceptor)` depends on `AuthApiService` depends on `HttpClient`.
  > 
  > [The way to fix this error is here.](#troubleshooting)

- `refreshThreshold?: number` - The coefficient of the token refresh threshold, if the expireIn access token approaches this coefficient, then the token will be refreshed. By default `0.8`.

- `saveRefreshTokenInStorage?: boolean` - Whether to save the refresh token that comes with authorization and / or when refreshing the token. By default `false`.
  > You should enable this option only if the server does not store the refresh token in the cookie, then to refresh the token you need to pass it in the refresh request, and you will have to store it on the client, which is initially a bad practice and can lead to problems in protecting the application by stealing access and refresh tokens.

  > **Notice:** if this option is enabled, then you should change `authTokenStorage` from `InMemoryTokenStorage` to any other predefined or custom `TokenStorage`. If this is not done, then the user will have to log in every time the page is updated, since when the page is updated, the memory and, accordingly, `InMemoryTokenStorage` will be cleared, this is how JS is arranged.

- `unAuthGuardRedirectUrl?: string` - The URL where the authorized user will be redirected to if he tries to access the route protected by UnAuthGuard. If you do not set a value, then routes protected by UnAuthGuard will simply reject the transition to this route.

- `authGuardRedirectUrl?: string` - The URL where an unauthorized user will be redirected to if they try to access a route protected by AuthGuard. If not set, then routes protected by AuthGuard will simply reject the transition to this route.

## List of predefined Token Storages

- `CookiesTokenStorage` - abstraction over cookies, saves tokens in cookies;
- `LocalStorageTokenStorage` - abstraction over localStorage, stores tokens in localStorage;
- `SessionStorageTokenStorage` - abstraction over sessionStorage, saves tokens in sessionStorage;
- `InMemoryTokenStorage` - saves tokens in the application memory, there are some drawbacks, when using this storage for authorization tokens, after reloading the page, a request will be made to update the access token (for SPA applications this is not critical), but the most secure storage for authorization tokens;

## Creating your own Token Storage

In order to create your own token storage, it is enough to implement the [BaseTokenStorage](./src/lib/token-storages/base-token-storage.ts) base class and specify an array of custom storage of tokens. Example:

```typescript
// my-custom-token-storage.ts
import { BaseTokenStorage } from '@dekh/ngx-jwt-auth';

export class MyCustomTokenStorage extends BaseTokenStorage {
  public get(key: string): string | null {
    // custom realisation
  }

  public set(key: string, token: string): void {
    // custom realisation
  }

  public delete(key: string): void {
    // custom realisation
  }

  // We can override the method to check the validity of tokens
  // but this is not recommended!
  public override isValid(key: string): boolean {
    // super.isValid();
    // custom realisation
  }
}
```

We define our storage in the parameters of the `JwtAuthModule` module:

```typescript
// app.module.ts
import { JwtAuthModule } from '@dekh/ngx-jwt-auth';
import { MyCustomTokenStorage } from '../auth';

@NgModule({
  imports: [
    JwtAuthModule.forRoot({
      customTokenStorages: [new MyCustomTokenStorage()],
    }),
  ],
})
export class AppModule {}
```

Or we can register our storage using the `TokenStorageRegistry` service:

```typescript
// app.service.ts
import {
  LocalStorageTokenStorage,
  InMemoryTokenStorage,
  TokenStorageRegistry
} from '@dekh/ngx-jwt-auth';
import { AuthApiService } from '../services';
import { MyCustomTokenStorage } from '../auth';

@NgModule({
  imports: [
    JwtAuthModule.forRoot({
      authApiService: AuthApiService,
      tokenStorage: LocalStorageTokenStorage,
      authTokenStorage: InMemoryTokenStorage,
    }),
  ],
})
export class AppModule {
  constructor(private readonly _tokenStorageRegistry: TokenStorageRegistry) {
    this._tokenStorageRegistry.register(new MyCustomTokenStorage());
  }
}
```

## Changing token storage at runtime

In rare cases, you may need to change the token storage at runtime, for this there are two services [TokenStorageManager](./src/lib/services/token-storage-manager.service.ts) and [AuthTokenStorageManager](./src/lib/services /auth-token-storage-manager.service.ts), both of these services have the same interaction interface. `TokenStorageManager` is used to manage the storage of __non-authorization__ tokens, and `AuthTokenStorageManager` is used to manage the storage of __authorization__ tokens.

Пример:

```typescript
// token-storage-changer.service.ts
import {
  AuthTokenStorageManager,
  TokenStorageRegistry,
  CookiesTokenStorage,
  BaseTokenStorage,
} from '@dekh/ngx-jwt-auth';
import { MyCustomTokenStorage } from '../auth';

@Injectable({
  provideIn: 'root'
})
export class TokenStorageChangerService {
  constructor(
    private readonly _authTokenStorageManager: AuthTokenStorageManager,
    private readonly _tokenStorageRegistry: TokenStrageRegistry,
  ) {
    this._tokenStorageRegistry.register(new MyCustomTokenStorage());
  }

  public setMyCustomStorage(): void {
    if (!this._tokenStorageRegistry.isRegistered(MyCustomTokenStorage)) {
      throw new Error('MyCustomTokenStorage is not registered!'); 
    }

    const myCustomStorage = this._tokenStorageRegistry.get(MyCustomTokenStorage);
    // or
    // const myCustomStorage = this._tokenStorageRegistry.get(new MyCustomTokenStorage());
    // or
    // const myCustomStorage = this._tokenStorageRegistry.get('MyCustomTokenStorage');
    this.changeAuthStorage(myCustomStorage);
  }

  public setCookiesStorage(): void {
    const cookiesStorage = this._tokenStorageRegistry.get(CookiesTokenStorage);
    // or
    // const cookiesStorage = this._tokenStorageRegistry.get(new CookiesTokenStorage());
    // or
    // const cookiesStorage = this._tokenStorageRegistry.get('CookiesTokenStorage');
    this.changeAuthStorage(storage);
  }

  public changeAuthStorage(storage: BaseTokenStorage): void {
    this._authTokenStorageManager.setStorage(storage);
  }
}
```

## Troubleshooting

- When starting the application, it gives an error __"ERROR Error: NG0200: Circular dependency in DI detected for JwtAuthService."__

  The reason for this error is a cyclic call to `JwtAuthInterceptor`. Since the interceptor handles every request, except for those url requests specified in the `unsecuredUrls` config parameter, the token refresh request creates a circular dependency.

  The solution to this problem is to specify in the `unsecuredUrls` array the URL or path of the accessToken update request, or specify the root path for all requests related to user authorization/registration, for example: `"/auth/"`, then all requests c path auth will be excluded from the interceptor check - `server.api/auth/login`, `server.api/auth/register`, `server.api/auth/refresh` and the like.